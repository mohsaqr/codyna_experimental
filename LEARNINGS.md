# Learnings

### 2026-02-14
- [non-ASCII]: R CMD check --as-cran fails on non-ASCII in R code files (em dashes, Greek letters). Use `--` instead of `---`, `tau` instead of `\u03C4`, `R^2` instead of `\u00b2`. The `tools::showNonASCIIfile()` function finds them.
- [R CMD check]: Must run `R CMD build` first to create tarball, then `R CMD check` on the tarball. Checking on the source directory fails with Authors@R parsing issues.
- [codyna internals]: `prepare_timeseries_data`, `check_missing`, `check_match`, `check_range`, `check_flag`, `check_class`, `stop_`, `warning_`, `message_`, `stopifnot_`, `ifelse_`, `try_`, `onlyif` are all defined in codyna's `utilities.R` and `check.R` (internal, not exported).
- [tna::tna()]: Accepts wide-format data.frame/tibble directly (T1, T2, T3, ...) via `build_model.data.frame`. No need for `tna::prepare_data()` which is for long-format event data.
- [stats::setNames]: `setNames()` moved to stats namespace; must use `stats::setNames()` to avoid R CMD check NOTE about undefined globals.
- [grid rendering]: Unicode characters in ggplot2 labels/subtitles cause `grid.Call(C_textBounds)` errors on some platforms. Always use ASCII in plot text.
- [spectral.R]: `stats::spectrum()` with `method = "pgram"` returns freq/spec vectors where `freq` is always positive (no need to filter for freq > 0 in practice, but we guard anyway). The spectral exponent (beta) is the *negative* of the log-log slope, so positive beta = reddened spectrum. Use `detrend = FALSE` in spectrum() when we handle detrending ourselves.
- [spectral.R]: The `spectral` S3 class follows the same pattern as `hurst`: tibble output with `structure()` wrapping, three-step edge interpolation (forward-fill, backward-fill, linear interp), and state classification via `cut()` with `right = FALSE`.
- [sensitivity.R]: `sensitivity_ews()` uses `check_match(..., several.ok = TRUE)` for `detrend_methods` since it accepts a character vector. The `%||%` operator from utilities.R is used for null-coalescing attribute access. Kendall tau via `stats::cor.test(..., method = "kendall")` returns the estimate in `$estimate`.
- [surrogates.R]: FFT phase randomization must preserve conjugate symmetry for real output: freq 0 phase = 0, Nyquist phase = 0 (if n even), and remaining phases mirrored (phases[n - idx + 2] = -phases[idx]). The `surrogate_test` class is `c("surrogate_test", "list")` since the return is a list not a tibble. Internal helpers follow `surrogate_{action}_()` naming. AAFT requires three steps: rank-order to Gaussian, phase-randomize, re-rank original values. Block bootstrap uses block length = sqrt(n).
- [potential.R]: The `potential` S3 class is `c("potential", "list")` since the return is a list not a tibble (it contains heterogeneous sub-objects: landscape tibble, wells tibble, barriers tibble, values vector). Internal helpers follow `potential_{action}_()` naming. Local minima/maxima detection uses sign changes in `diff()` with forward-filling for zeros. The Boltzmann relationship U(x) = -log(P(x)) requires adding `eps = .Machine$double.eps` to density values before taking log. For rolling-window mode, the global landscape is also computed for reference and stored in the same object. Detrend="diff" reduces series length by 1 and the time vector must be trimmed accordingly.
- [changepoint.R]: PELT pruning must evaluate all candidates first to determine `best_cost`, then prune in a second pass using `cost_val <= best_cost + pen`. Doing pruning during the first pass uses a potentially stale `best_cost`. The `changepoint` S3 class is `c("changepoint", "tbl_df", "tbl", "data.frame")` with columns time, value, segment, regime, segment_mean, segment_var, level, direction, magnitude, changepoint_type, state, changepoint. Smart regime IDs group segments with similar means (within 0.5*SD threshold); `changepoint_type` is "change" (new regime) or "return" (revisited regime), only populated at changepoint rows. `state` combines level + changepoint_type (e.g., high_change, low_return, medium_initial). `to_tna.changepoint()` accepts `state` argument: "state" (default), "level", "direction", "regime", "segment". Changepoint locations are stored as an attribute (integer positions in the series). The `changepoint` column marks position `cp + 1` (first observation of new segment), not the last observation of the old segment. Segment parameter `min_segment` is different from the general `min_points` convention -- it represents minimum segment length between changepoints.
- [changepoint cost functions]: The `changepoint` R package uses different cost functions per change type: RSS (`sum((x-mean)^2)`) for `cpt.mean`, `n*log(var)` for `cpt.var`, `n*log(var)+n` for `cpt.meanvar`. BIC penalty is `p*log(n)` where p=2 for mean/variance changes, p=3 for both; AIC is `2*p`. Our `changepoint_cost_()` and `changepoint_penalty_()` now match these exactly.
- [numerical equivalence]: All 6 R files (spectral, potential, surrogates, changepoint, sensitivity, multivariate_ews) verified against manual base R computations: 89 tests total, 0 failures. Key: phase surrogates preserve raw |FFT|^2 exactly but NOT stats::spectrum() periodograms (which apply smoothing). MAF eigenvalues and components match reference implementation exactly. PELT may find more changepoints than expected -- test segment statistics for ALL segments, not just first/last.
- [external equivalence]: All 6 new R files validated against external packages (550 iterations, 0 failures): changepoint PELT/BinSeg vs `changepoint::cpt.mean()`, multivariate EWS vs `EWSmethods::multiEWS()`, phase surrogates vs `nonlinearTseries::FFTsurrogate()`, spectral/sensitivity/potential/surrogates vs manual `stats::` computations.
- [eigenMAF sign]: EWSmethods negates eigenMAF values so increasing values indicate rising spatial correlation (approaching transition). Our `mews_window_metrics()` now matches this: `out[metric] <- -min(maf_res$eigen_values) / sum(maf_res$eigen_values)`.
- [EWSmethods API]: `multiEWS()` metrics parameter must be an explicit vector (not "all"). `$EWS$cor` returns a data.frame, not a named vector. `$EWS$raw` is a data.frame with metric columns.
- [codyna %||%]: The `%||%` operator is defined in codyna's utilities.R but is not exported. When testing outside the package namespace, define it inline: `` `%||%` <- function(x, y) if (is.null(x)) y else x ``
- [convention audit]: All 11 R files now pass convention checks: no base `stop()`/`stopifnot()`/`tryCatch()` in any file, `window` parameter used consistently (not `winsize`), no `scales::rescale()` dependency, all error handling uses `stop_()`, `stopifnot_()`, `try_()`.

### 2026-02-15
- [generate_tipping_data]: Now has `model` parameter: `"ou"` (default, Ornstein-Uhlenbeck with decaying restoring force) and `"ar"` (original AR model with growing coefficient). The OU model produces clean critical slowing down: AR(1) ramps from ~0.34 to ~0.87, variance from ~3 to ~137. New defaults: `n_time = 200`, `tipping_point = 100`, `stability_strength = 0.5`, `saturation_point = 180`. Tests calling `generate_tipping_data()` with `n_time` < 100 must explicitly pass `tipping_point` and `saturation_point` since the new defaults (100, 180) will exceed `n_time`.
- [generate_tipping_data OU model]: The key insight: the old AR model (`x[t] = phi * x[t-1] + N(20, 5)`) had an additive mean = 20 that created a non-zero-mean process masking the CSD signal. The OU formulation (`x[t] = x[t-1] + lambda * (baseline - x[t-1]) + noise`) is mean-reverting around baseline, so the AR structure is clean. As lambda decays from 0.5 toward 0, AR(1) coefficient = (1 - lambda) approaches 1.
- [surrogate plot labels]: `ggplot2::annotate("text")` with `x = observed_tau, hjust = -0.1` clips when tau is at the far right of the histogram. Fix: use `ggplot2::annotate("label")` anchored at `x = Inf, hjust = 1.05` (top-right corner) with `fill = "white", label.size = 0` for a clean background box.
- [p-value formatting]: Never display `p = 0.0000`. Use `surrogate_format_p_()`: if p < 0.001 return `"p < 0.001"`, else `sprintf("p = %.3f", p)`. Applied to plot labels, print, and summary methods.
- [external equivalence]: Updated to 800 iterations (8 test suites x 100), 0 failures. Tests now pass `tipping_point` and `saturation_point` explicitly to `generate_tipping_data()` to accommodate new defaults.
